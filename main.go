package main

import (
	"context"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws"
	awsconfig "github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/ssm"
	"github.com/joho/godotenv"
	flag "github.com/spf13/pflag"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type CommandLine struct {
	Template string
	Output   string
	Settings []string
}

func main() {
	var commandLine CommandLine
	var help bool
	flag.BoolVarP(&help, "help", "h", help, "Show help")
	flag.StringVarP(&commandLine.Template, "template", "t", commandLine.Template, "Template file (required)")
	flag.StringVarP(&commandLine.Output, "output", "o", "", "Output file (required)")
	flag.StringArrayVarP(&commandLine.Settings, "settings", "s", nil, "Settings, can be repeated")
	flag.Parse()

	if len(os.Args) == 1 || help {
		fmt.Fprintf(os.Stderr, "Template processor using the Go text template syntax\n")
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n", programName())
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
		fmt.Fprintln(os.Stderr, "\nSettings can be any of:")
		fmt.Fprintln(os.Stderr, " - An environment file (ie contains lines in the format KEY=VALUE)")
		fmt.Fprintln(os.Stderr, " - A reference to AWS SSM Parameters in the format ssm:/path")
		fmt.Fprintln(os.Stderr, "\nWhen there are multiple settings, the setting can use values defined previously.")
		fmt.Fprintf(os.Stderr, "eg: -s /etc/defaults/myservice -s ssm://myservice/{{.ENVIRONMENT}}\n\n")
		fmt.Fprintln(os.Stderr, "https://github.com/jjeffery/gotmpl")
		fmt.Fprintln(os.Stderr, "https://go.dev/text/template")
		os.Exit(1)
	}

	if commandLine.Template == "" {
		fmt.Fprintf(os.Stderr, "--template is required\n")
		os.Exit(1)
	}

	if commandLine.Output == "" {
		fmt.Fprintf(os.Stderr, "--output is required\n")
		os.Exit(1)
	}

	if len(commandLine.Settings) == 0 {
		fmt.Fprintf(os.Stderr, "specify one or more --settings\n")
		os.Exit(1)
	}

	if err := doWork(&commandLine); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func programName() string {
	fileName := filepath.Base(os.Args[0])
	if strings.ToLower(filepath.Ext(fileName)) == ".exe" {
		fileName = fileName[:len(fileName)-4]
	}
	return fileName
}

func doWork(commandLine *CommandLine) error {
	variables := make(map[string]any)
	variables["ansible_managed"] = fmt.Sprintf("Generated by %s", programName())
	for _, settingsTemplate := range commandLine.Settings {
		if strings.HasPrefix(settingsTemplate, "ssm:") {
			path, err := processStringTemplate(settingsTemplate[4:], variables)
			if err != nil {
				return err
			}

			if err := getParams(path, variables); err != nil {
				return err
			}
			continue
		}

		fileName, err := processStringTemplate(settingsTemplate, variables)
		if err != nil {
			return err
		}

		ext := filepath.Ext(fileName)
		switch strings.ToLower(ext) {
		case ".json", ".yml", ".yaml", ".ini", ".toml":
			return fmt.Errorf("%s settings files are not supported yet", ext)
		default:
			if err := getEnv(fileName, variables); err != nil {
				return err
			}
		}
	}

	changed, err := buildFile(commandLine.Template, commandLine.Output, variables)
	if err != nil {
		return err
	}
	if changed {
		fmt.Println(commandLine.Output)
	}

	return nil
}

func getParams(ssmPrefix string, variables map[string]any) error {
	ctx := context.TODO()
	cfg, err := awsconfig.LoadDefaultConfig(ctx)
	if err != nil {
		return err
	}
	svc := ssm.NewFromConfig(cfg)
	variables["aws_region"] = cfg.Region
	input := ssm.GetParametersByPathInput{
		Path:           aws.String(ssmPrefix),
		WithDecryption: aws.Bool(true),
		Recursive:      aws.Bool(true),
	}
	for {
		output, err := svc.GetParametersByPath(ctx, &input)
		if err != nil {
			return err
		}
		for _, p := range output.Parameters {
			name := *p.Name
			if strings.HasPrefix(name, ssmPrefix) {
				name = name[len(ssmPrefix):]
			}
			for strings.HasPrefix(name, "/") {
				name = name[1:]
			}
			dirs := strings.Split(name, "/")
			name = dirs[len(dirs)-1]
			dirs = dirs[:len(dirs)-1]
			vars := variables
			for _, dir := range dirs {
				switch v := vars[dir].(type) {
				case map[string]any:
					vars = v
				default:
					newV := make(map[string]any)
					vars[dir] = newV
					vars = newV
				}
			}

			value := *p.Value
			vars[name] = value
		}

		if output.NextToken == nil {
			break
		}
		input.NextToken = output.NextToken
	}
	return nil
}

func getEnv(envFile string, variables map[string]any) error {
	m, err := godotenv.Read(envFile)
	if err != nil {
		return fmt.Errorf("cannot read env files: %w", err)
	}
	for name, value := range m {
		variables[name] = value
	}
	return nil
}

func buildFile(templateFileName string, outputFileName string, variables map[string]any) (changed bool, err error) {
	tmpl, err := template.New(filepath.Base(templateFileName)).Funcs(templateFuncs).ParseFiles(templateFileName)
	if err != nil {
		return false, fmt.Errorf("cannot parse %s: %w", templateFileName, err)
	}
	tempFile, err := os.CreateTemp("", programName())
	if err != nil {
		return false, fmt.Errorf("cannot create temporary file: %w", err)
	}
	tempFileName := tempFile.Name()
	deleteTempFile := func() {
		_ = tempFile.Close()
		_ = os.Remove(tempFile.Name())
	}
	if err := tmpl.Execute(tempFile, variables); err != nil {
		deleteTempFile()
		return false, fmt.Errorf("cannot execute %s: %w", templateFileName, err)
	}
	if err := tempFile.Close(); err != nil {
		_ = os.Remove(tempFile.Name())
		return false, fmt.Errorf("cannot close %s: %w", tempFile.Name(), err)
	}

	changed = areFilesDifferent(tempFile.Name(), outputFileName)
	if changed {
		src, err := os.Open(tempFileName)
		if err != nil {
			return false, err
		}
		dest, err := os.Create(outputFileName)
		if err != nil {
			_ = os.Remove(tempFileName)
			return false, fmt.Errorf("cannot open %s: %w", outputFileName, err)
		}
		if _, err := io.Copy(dest, src); err != nil {
			_ = os.Remove(tempFileName)
			return false, fmt.Errorf("cannot write to %s: %w", outputFileName, err)
		}
	}

	return changed, nil
}

func areFilesDifferent(fileName1, fileName2 string) bool {
	fileInfo1, err := os.Stat(fileName1)
	if err != nil {
		return true
	}
	fileInfo2, err := os.Stat(fileName2)
	if err != nil {
		return true
	}
	if fileInfo1.Size() != fileInfo2.Size() {
		return true
	}

	file1Contents, err := ioutil.ReadFile(fileName1)
	if err != nil {
		return true
	}
	file2Contents, err := ioutil.ReadFile(fileName2)
	if err != nil {
		return true
	}
	file1Text := string(file1Contents)
	file2Text := string(file2Contents)

	return file1Text != file2Text
}

func processStringTemplate(input string, variables map[string]any) (string, error) {
	if !strings.Contains(input, "{{") {
		return input, nil
	}
	tmpl, err := template.New("").Funcs(templateFuncs).Parse(input)
	if err != nil {
		return "", fmt.Errorf("cannot parse '%s': %w", input, err)
	}
	var sb strings.Builder
	if err := tmpl.Execute(&sb, variables); err != nil {
		return "", fmt.Errorf("cannot execute '%s': %w", input, err)
	}
	return sb.String(), nil
}

var (
	templateFuncs = template.FuncMap{
		"cs": connectionString,
	}
)

func connectionString(cs string, key string) string {
	splits := strings.Split(cs, ";")
	key = strings.ToLower(key)
	for _, split := range splits {
		k, v, found := strings.Cut(split, "=")
		if found && key == strings.ToLower(k) {
			return v
		}
	}
	return ""
}
