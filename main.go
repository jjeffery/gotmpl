package main

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/aws/aws-sdk-go-v2/aws"
	awsconfig "github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/ssm"
	"github.com/joho/godotenv"
	flag "github.com/spf13/pflag"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

type ConfigFile struct {
	Templates []TemplateConfig `json:"templates"`
}

type TemplateConfig struct {
	SourceTemplate  string `json:"source_template"`
	DestinationFile string `json:"destination_file"`
	ServiceName     string `json:"service_name"`
}

type CommandLine struct {
	ConfigFile string
	ParamPaths []string
	EnvFiles   []string
}

func main() {
	var commandLine CommandLine
	var help bool
	flag.BoolVarP(&help, "help", "h", help, "Show help")
	flag.StringVarP(&commandLine.ConfigFile, "config", "c", commandLine.ConfigFile, "Config file")
	flag.StringArrayVarP(&commandLine.ParamPaths, "param-path", "p", nil, "SSM parameter path, can be repeated")
	flag.StringArrayVarP(&commandLine.EnvFiles, "env-file", "e", nil, "Environment file, can be repeated")
	flag.Parse()

	if help {
		fmt.Fprintf(os.Stderr, "Generate configuration files from templates and AWS SSM parameters\n")
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n", programName())
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
		os.Exit(1)
	}

	if commandLine.ConfigFile == "" {
		fmt.Fprintf(os.Stderr, "--config is required\n")
		os.Exit(1)
	}

	if len(commandLine.ParamPaths) == 0 && len(commandLine.EnvFiles) == 0 {
		fmt.Fprintf(os.Stderr, "specify --param-paths or --env-files\n")
		os.Exit(1)
	}

	if err := doWork(&commandLine); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func programName() string {
	fileName := filepath.Base(os.Args[0])
	if strings.ToLower(filepath.Ext(fileName)) == ".exe" {
		fileName = fileName[:len(fileName)-4]
	}
	return fileName
}

func doWork(commandLine *CommandLine) error {
	config, err := getConfig(commandLine.ConfigFile)
	if err != nil {
		return err
	}
	variables := make(map[string]any)
	variables["ansible_managed"] = fmt.Sprintf("Generated by %s", programName())
	if err := getParams(commandLine.ParamPaths, variables); err != nil {
		return err
	}
	if len(commandLine.EnvFiles) > 0 {
		if err := getEnv(commandLine.EnvFiles, variables); err != nil {
			return err
		}
	}

	for _, templateConfig := range config.Templates {
		changed, err := buildFile(templateConfig, variables)
		if err != nil {
			return err
		}
		if changed {
			fmt.Println(templateConfig.DestinationFile)
		}
	}

	return nil
}

func getConfig(configFileName string) (*ConfigFile, error) {
	file, err := os.Open(configFileName)
	if err != nil {
		return nil, err
	}
	defer func(file *os.File) {
		_ = file.Close()
	}(file)
	decoder := json.NewDecoder(file)
	var config ConfigFile
	if err := decoder.Decode(&config); err != nil {
		return nil, err
	}
	return &config, nil
}

func getParams(ssmPrefixes []string, variables map[string]any) error {
	ctx := context.TODO()
	cfg, err := awsconfig.LoadDefaultConfig(ctx)
	if err != nil {
		return err
	}
	svc := ssm.NewFromConfig(cfg)
	variables["aws_region"] = cfg.Region
	for _, ssmPrefix := range ssmPrefixes {
		input := ssm.GetParametersByPathInput{
			Path:           aws.String(ssmPrefix),
			WithDecryption: aws.Bool(true),
			Recursive:      aws.Bool(true),
		}
		for {
			output, err := svc.GetParametersByPath(ctx, &input)
			if err != nil {
				return err
			}
			for _, p := range output.Parameters {
				name := *p.Name
				if strings.HasPrefix(name, ssmPrefix) {
					name = name[len(ssmPrefix):]
				}
				for strings.HasPrefix(name, "/") {
					name = name[1:]
				}
				dirs := strings.Split(name, "/")
				name = dirs[len(dirs)-1]
				dirs = dirs[:len(dirs)-1]
				vars := variables
				for _, dir := range dirs {
					switch v := vars[dir].(type) {
					case map[string]any:
						vars = v
					default:
						newV := make(map[string]any)
						vars[dir] = newV
						vars = newV
					}
				}

				value := *p.Value
				vars[name] = value
			}

			if output.NextToken == nil {
				break
			}
			input.NextToken = output.NextToken
		}
	}
	return nil
}

func getEnv(envFiles []string, variables map[string]any) error {
	m, err := godotenv.Read(envFiles...)
	if err != nil {
		return fmt.Errorf("cannot read env files: %w", err)
	}
	for name, value := range m {
		variables[name] = value
	}
	return nil
}

func buildFile(templateConfig TemplateConfig, variables map[string]any) (changed bool, err error) {
	tmpl, err := template.New(templateConfig.SourceTemplate).Funcs(template.FuncMap{
		"cs": connectionString,
	}).ParseFiles(templateConfig.SourceTemplate)
	if err != nil {
		return false, fmt.Errorf("cannot parse %s: %w", templateConfig.SourceTemplate, err)
	}
	tempFile, err := os.CreateTemp("", programName())
	if err != nil {
		return false, fmt.Errorf("cannot create temporary file: %w", err)
	}
	tempFileName := tempFile.Name()
	deleteTempFile := func() {
		_ = tempFile.Close()
		_ = os.Remove(tempFile.Name())
	}
	if err := tmpl.Execute(tempFile, variables); err != nil {
		deleteTempFile()
		return false, fmt.Errorf("cannot execute %s: %w", templateConfig.SourceTemplate, err)
	}
	if err := tempFile.Close(); err != nil {
		_ = os.Remove(tempFile.Name())
		return false, fmt.Errorf("cannot close %s: %w", tempFile.Name(), err)
	}

	changed = areFilesDifferent(tempFile.Name(), templateConfig.DestinationFile)
	if changed {
		src, err := os.Open(tempFileName)
		if err != nil {
			return false, err
		}
		dest, err := os.Create(templateConfig.DestinationFile)
		if err != nil {
			_ = os.Remove(tempFileName)
			return false, fmt.Errorf("cannot open %s: %w", templateConfig.DestinationFile, err)
		}
		if _, err := io.Copy(dest, src); err != nil {
			_ = os.Remove(tempFileName)
			return false, fmt.Errorf("cannot write to %s: %w", templateConfig.DestinationFile, err)
		}
	}

	return changed, nil
}

func areFilesDifferent(fileName1, fileName2 string) bool {
	fileInfo1, err := os.Stat(fileName1)
	if err != nil {
		return true
	}
	fileInfo2, err := os.Stat(fileName2)
	if err != nil {
		return true
	}
	if fileInfo1.Size() != fileInfo2.Size() {
		return true
	}

	file1Contents, err := ioutil.ReadFile(fileName1)
	if err != nil {
		return true
	}
	file2Contents, err := ioutil.ReadFile(fileName2)
	if err != nil {
		return true
	}
	file1Text := string(file1Contents)
	file2Text := string(file2Contents)

	return file1Text != file2Text
}

func connectionString(cs string, key string) string {
	splits := strings.Split(cs, ";")
	key = strings.ToLower(key)
	for _, split := range splits {
		k, v, found := strings.Cut(split, "=")
		if found && key == strings.ToLower(k) {
			return v
		}
	}
	return ""
}
